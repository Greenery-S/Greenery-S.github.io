<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Greenery&#39;s Blog Site</title>
    <link>https://Greenery-S.github.io/</link>
    <description>Recent content on Greenery&#39;s Blog Site</description>
    <generator>Hugo</generator>
    <language>en</language>
    <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
    <lastBuildDate>Sun, 26 May 2024 00:58:41 +0800</lastBuildDate>
    <atom:link href="https://Greenery-S.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Argo Workflow 5</title>
      <link>https://Greenery-S.github.io/posts/devops/argo-workflow/argo-workflow-5/</link>
      <pubDate>Sun, 26 May 2024 00:58:41 +0800</pubDate>
      <guid>https://Greenery-S.github.io/posts/devops/argo-workflow/argo-workflow-5/</guid>
      <description>Argo Workflow (5) 1 Loops When writing workflows, it is often useful to iterate over a set of inputs. This is how Argo Workflows handle looping.&#xA;There are three basic ways to run a template multiple times:&#xA;withSequence iterates over a sequence of numbers. withItems accepts a list of items to process, which can be: Plain single values, accessible via {{item}} in the template. JSON objects, where each element can be referenced by its key as {{item.</description>
    </item>
    <item>
      <title>Argo Workflow 4</title>
      <link>https://Greenery-S.github.io/posts/devops/argo-workflow/argo-workflow-4/</link>
      <pubDate>Sat, 25 May 2024 22:25:36 +0800</pubDate>
      <guid>https://Greenery-S.github.io/posts/devops/argo-workflow/argo-workflow-4/</guid>
      <description>Argo Workflow (4) 1 Secrets Argo Workflow supports the use of Kubernetes Secrets within workflows. A Secret is an object used to store sensitive information, such as passwords, OAuth tokens, etc. Secrets can be stored in Etcd in plain text or base64 encoded form. When using a Secret in a workflow, you need to define a secrets field in the workflow spec, and then reference it in the workflow template using {{workflow.</description>
    </item>
    <item>
      <title>Argo Workflow 3</title>
      <link>https://Greenery-S.github.io/posts/devops/argo-workflow/argo-workflow-3/</link>
      <pubDate>Sat, 25 May 2024 17:14:53 +0800</pubDate>
      <guid>https://Greenery-S.github.io/posts/devops/argo-workflow/argo-workflow-3/</guid>
      <description>Argo Workflow (3) 1 Artifacts When running workflows, it is very common for steps to generate or use artifacts. Typically, an output artifact from one step may be used as an input artifact by a subsequent step.&#xA;The following workflow specification contains two sequential steps. The first step, named generate-artifact, uses the argosay template to generate an artifact, which is then used by the second step, named print-message, which consumes the generated artifact.</description>
    </item>
    <item>
      <title>Argo Workflow 2</title>
      <link>https://Greenery-S.github.io/posts/devops/argo-workflow/argo-workflow-2/</link>
      <pubDate>Sat, 25 May 2024 14:30:03 +0800</pubDate>
      <guid>https://Greenery-S.github.io/posts/devops/argo-workflow/argo-workflow-2/</guid>
      <description>Argo Workflow (2) 1 Steps Multi-step workflows can be defined through the steps field. Each step is an independent container that can be executed in parallel.&#xA;apiVersion: argoproj.io/v1alpha1 kind: Workflow metadata: generateName: steps- spec: entrypoint: hello-hello-hello # This spec contains two templates: hello-hello-hello and whalesay templates: - name: hello-hello-hello # Instead of just running a container # This template has a sequence of steps steps: - - name: hello1 # hello1 is run before the following steps template: argosay arguments: parameters: - name: message value: &amp;#34;hello1&amp;#34; - - name: hello2a # double dash =&amp;gt; run after previous step template: argosay arguments: parameters: - name: message value: &amp;#34;hello2a&amp;#34; - name: hello2b # single dash =&amp;gt; run in parallel with previous step template: argosay arguments: parameters: - name: message value: &amp;#34;hello2b&amp;#34; # This is the same template as from the previous example - name: argosay inputs: parameters: - name: message container: image: yky8/argosay:v2 command: [ &amp;#34;/usr/local/bin/argosay&amp;#34; ] args: [ &amp;#34;echo&amp;#34;,&amp;#34;{{inputs.</description>
    </item>
    <item>
      <title>Argo Workflow 1</title>
      <link>https://Greenery-S.github.io/posts/devops/argo-workflow/argo-workflow-1/</link>
      <pubDate>Sat, 25 May 2024 03:46:15 +0800</pubDate>
      <guid>https://Greenery-S.github.io/posts/devops/argo-workflow/argo-workflow-1/</guid>
      <description>Argo Workflow (1) A lot of examples can be found here: https://github.com/argoproj/argo-workflows/tree/main/examples However, since the docker/whalesay image is no longer supported, many examples cannot run, and you need to build an image to replace it.&#xA;1 Argo CLI argo submit hello-world.yaml # submit a workflow spec to Kubernetes argo list # list current workflows argo get hello-world-xxx # get info about a specific workflow argo logs hello-world-xxx # print the logs from a workflow argo delete hello-world-xxx # delete workflow You can also use kubectl, but you need to specify the namespace.</description>
    </item>
    <item>
      <title>Quick Start With Self Build Image</title>
      <link>https://Greenery-S.github.io/posts/devops/argo-workflow/quick-start-with-self-build-image/</link>
      <pubDate>Sat, 25 May 2024 02:17:44 +0800</pubDate>
      <guid>https://Greenery-S.github.io/posts/devops/argo-workflow/quick-start-with-self-build-image/</guid>
      <description>A Somewhat Rocky &amp;ldquo;Quick&amp;rdquo; Start Recently, I wanted to review Argo Workflow, so I decided to start from the official documentation and follow the steps one by one. However, things didn&amp;rsquo;t go as smoothly as expected. The official docker/whalesay image is no longer supported in the latest Docker version, which has caused hundreds of hello world examples based on it to fail to run properly. So, I decided to build my own image to replace the official docker/whalesay image.</description>
    </item>
    <item>
      <title>Hash Function vs Symmetric Encryption</title>
      <link>https://Greenery-S.github.io/posts/go/encryption/hash-function-vs-symmetric-encryption/</link>
      <pubDate>Wed, 22 May 2024 23:29:47 +0800</pubDate>
      <guid>https://Greenery-S.github.io/posts/go/encryption/hash-function-vs-symmetric-encryption/</guid>
      <description>Core Differences between Symmetric Encryption and Hash Functions 1 Symmetric Encryption Purpose: Protect the confidentiality of data, preventing unauthorized access.&#xA;Working Principle: Utilizes the same key for both encryption and decryption of data.&#xA;Characteristics:&#xA;Reversibility: Decrypting ciphertext to retrieve the original data using the same key is possible. Key Management: Securely sharing the key is crucial, as data remains inaccessible without it. Applications: Secure communication, data storage, digital signatures, etc.</description>
    </item>
    <item>
      <title>Open Compare to Openfile</title>
      <link>https://Greenery-S.github.io/posts/go/memo/open-compare-to-openfile/</link>
      <pubDate>Wed, 22 May 2024 22:15:28 +0800</pubDate>
      <guid>https://Greenery-S.github.io/posts/go/memo/open-compare-to-openfile/</guid>
      <description>os.Open vs. os.OpenFile 1 Differences In Go, both os.Open and os.OpenFile are functions used to open files, but they have different usage scenarios and functionalities.&#xA;os.Open: This is a simpler function for opening files. It takes only one argument, the path to the file to be opened. It opens the file in read-only mode and returns an error if the file does not exist. file, err := os.Open(&amp;#34;example.txt&amp;#34;) if err !</description>
    </item>
    <item>
      <title>File Encryption</title>
      <link>https://Greenery-S.github.io/posts/go/encryption/file-encryption/</link>
      <pubDate>Wed, 22 May 2024 17:42:47 +0800</pubDate>
      <guid>https://Greenery-S.github.io/posts/go/encryption/file-encryption/</guid>
      <description>File Encryption code: https://github.com/Greenery-S/go-encryption/tree/master/enc_file&#xA;1 Symmetric Encryption Every step of the encryption process is reversible The same set of keys is used for encryption and decryption XOR is the simplest symmetric encryption algorithm Typical symmetric encryption algorithms: DES (Data Encryption Standard), AES (Advanced Encryption Standard)&#xA;2 Group Encryption Group encryption: The original data (plaintext) is grouped, each group is 64 bits, and when the last group is less than 64 bits, it is filled according to certain rules.</description>
    </item>
    <item>
      <title>Introduction to Clickhouse</title>
      <link>https://Greenery-S.github.io/posts/go/database/introduction-to-clickhouse/</link>
      <pubDate>Wed, 22 May 2024 15:08:40 +0800</pubDate>
      <guid>https://Greenery-S.github.io/posts/go/database/introduction-to-clickhouse/</guid>
      <description>ClickHouse code: https://github.com/Greenery-S/go-database/tree/master/clickhouse&#xA;1 Introduction ClickHouse is a columnar database management system (DBMS) for online analytical processing (OLAP).&#xA;In traditional row-based database systems (MySQL, SQL Server), data in the same row is always physically stored together. In columnar database systems (ClickHouse, HBase, Druid), data from the same column is stored together.&#xA;Key characteristics of OLAP scenarios (statistical analysis based on event tracking data):&#xA;The vast majority are read requests, and data added to the database cannot be modified.</description>
    </item>
  </channel>
</rss>
