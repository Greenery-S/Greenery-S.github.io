<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Greenery&#39;s Blog Site</title>
    <link>https://Greenery-S.github.io/zh-cn/</link>
    <description>Recent content on Greenery&#39;s Blog Site</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
    <lastBuildDate>Sun, 26 May 2024 22:52:54 +0800</lastBuildDate>
    <atom:link href="https://Greenery-S.github.io/zh-cn/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Argo Workflow 7</title>
      <link>https://Greenery-S.github.io/zh-cn/posts/devops/argo-workflow/argo-workflow-7/</link>
      <pubDate>Sun, 26 May 2024 22:52:54 +0800</pubDate>
      <guid>https://Greenery-S.github.io/zh-cn/posts/devops/argo-workflow/argo-workflow-7/</guid>
      <description>Argo Workflow (7) Walk through 章节的相关特性还剩下:&#xA;Kubernetes Resource https://argo-workflows.readthedocs.io/en/latest/walk-through/kubernetes-resources/ Daemon Container Sidecar Container Custom Template Variables Continuous Integration Example 下次有机会再总结. 目前学的这些够用了.</description>
    </item>
    <item>
      <title>Argo Workflow 6</title>
      <link>https://Greenery-S.github.io/zh-cn/posts/devops/argo-workflow/argo-workflow-6/</link>
      <pubDate>Sun, 26 May 2024 14:36:26 +0800</pubDate>
      <guid>https://Greenery-S.github.io/zh-cn/posts/devops/argo-workflow/argo-workflow-6/</guid>
      <description>Argo Workflow (6) 1 Conditionals 支持条件执行.语法是由 govaluate 实现的,它提供了对复杂语法的支持.请参见以下示例:&#xA;apiVersion: argoproj.io/v1alpha1 kind: Workflow metadata: generateName: coinflip- spec: entrypoint: coinflip templates: - name: coinflip steps: # flip a coin - - name: flip-coin template: flip-coin # evaluate the result in parallel - - name: heads template: heads # call heads template if &amp;#34;heads&amp;#34; when: &amp;#34;{{steps.flip-coin.outputs.result}} == heads&amp;#34; - name: tails template: tails # call tails template if &amp;#34;tails&amp;#34; when: &amp;#34;{{steps.flip-coin.outputs.result}} == tails&amp;#34; - - name: flip-again template: flip-coin - - name: complex-condition template: heads-tails-or-twice-tails # call heads template if first flip was &amp;#34;heads&amp;#34; and second was &amp;#34;tails&amp;#34; OR both were &amp;#34;tails&amp;#34; when: &amp;gt;- ( {{steps.</description>
    </item>
    <item>
      <title>Argo Workflow 5</title>
      <link>https://Greenery-S.github.io/zh-cn/posts/devops/argo-workflow/argo-workflow-5/</link>
      <pubDate>Sun, 26 May 2024 00:58:41 +0800</pubDate>
      <guid>https://Greenery-S.github.io/zh-cn/posts/devops/argo-workflow/argo-workflow-5/</guid>
      <description>Argo Workflow (5) 1 Loops 编写工作流时，能够迭代一组输入是非常有用的，因为这就是 Argo Workflows 执行循环的方式。&#xA;有三种基本方法可以多次运行一个模板。&#xA;withSequence 迭代一个数字序列。 withItems 接受一个待处理的项目列表，可以是 纯的单个值，在模板中可以通过 {{item}} 使用 JSON 对象，其中每个元素可以通过它的键作为 {{item.key}} 来引用 withParam 接受一个 JSON 数组，并对其进行迭代——同样地，这些项目可以像 withItems 一样是对象。这非常强大，因为你可以在工作流的另一步生成 JSON，从而创建一个动态工作流。 withSequence 示例 apiVersion: argoproj.io/v1alpha1 kind: Workflow metadata: generateName: loop-sequence- spec: entrypoint: loop-sequence-example templates: - name: loop-sequence-example steps: - - name: hello-world-x5 template: hello-world withSequence: count: &amp;#34;5&amp;#34; - name: hello-world container: image: yky8/argosay:v2 command: [ &amp;#34;/usr/local/bin/argosay&amp;#34; ] args: [ &amp;#34;echo&amp;#34;,&amp;#34;hello world!&amp;#34; ] argo submit loop-withsequence.</description>
    </item>
    <item>
      <title>Argo Workflow 4</title>
      <link>https://Greenery-S.github.io/zh-cn/posts/devops/argo-workflow/argo-workflow-4/</link>
      <pubDate>Sat, 25 May 2024 22:25:36 +0800</pubDate>
      <guid>https://Greenery-S.github.io/zh-cn/posts/devops/argo-workflow/argo-workflow-4/</guid>
      <description>Argo Workflow (4) 1 Secrets Argo Workflow支持在workflow中使用Kubernetes的Secret。Secret是一种用来存储敏感信息的对象，比如密码、OAuth令牌等。Secret可以以明文或base64编码的形式存储在Etcd中。在workflow中使用Secret时，需要在workflow的spec中定义一个secrets字段，然后在workflow的template中使用{{workflow.spec.secrets}}引用。&#xA;先创建一个secret，然后在workflow中使用这个secret。&#xA;kubectl create secret generic my-secret --from-literal=mypassword=S00perS3cretPa55word -n argo # To run this example, first create the secret by running: # kubectl create secret generic my-secret --from-literal=mypassword=S00perS3cretPa55word apiVersion: argoproj.io/v1alpha1 kind: Workflow metadata: generateName: secret-example- spec: entrypoint: argosay # To access secrets as files, add a volume entry in spec.volumes[] and # then in the container template spec, add a mount using volumeMounts. volumes: - name: my-secret-vol secret: secretName: my-secret # name of an existing k8s secret templates: - name: argosay container: image: alpine:3.</description>
    </item>
    <item>
      <title>Argo Workflow 3</title>
      <link>https://Greenery-S.github.io/zh-cn/posts/devops/argo-workflow/argo-workflow-3/</link>
      <pubDate>Sat, 25 May 2024 17:14:53 +0800</pubDate>
      <guid>https://Greenery-S.github.io/zh-cn/posts/devops/argo-workflow/argo-workflow-3/</guid>
      <description>Argo Workflow (3) 1 Artifacts 在运行工作流时，步骤生成或使用工件是非常常见的情况。通常，一个步骤的输出工件可能会被后续步骤作为输入工件使用。&#xA;下面的工作流规范包含两个按顺序运行的步骤。第一个名为 generate-artifact 的步骤将使用 argosay 模板生成一个工件，该工件将被第二个名为 print-message 的步骤使用，print-message 将消费生成的工件。&#xA;apiVersion: argoproj.io/v1alpha1 kind: Workflow metadata: generateName: artifact-passing- spec: entrypoint: artifact-example templates: - name: artifact-example steps: - - name: generate-artifact template: argosay - - name: consume-artifact template: print-message arguments: artifacts: # bind message to the hello-art artifact # generated by the generate-artifact step - name: message from: &amp;#34;{{steps.generate-artifact.outputs.artifacts.hello-art}}&amp;#34; - name: argosay container: image: yky8/argosay:v2 # sh -c，你可以在其后面提供一个字符串， # 这个字符串将被 sh 作为一个完整的 shell 命令来执行 command: [sh, -c] # The tee command is used in Linux and Unix systems.</description>
    </item>
    <item>
      <title>Argo Workflow 2</title>
      <link>https://Greenery-S.github.io/zh-cn/posts/devops/argo-workflow/argo-workflow-2/</link>
      <pubDate>Sat, 25 May 2024 14:30:03 +0800</pubDate>
      <guid>https://Greenery-S.github.io/zh-cn/posts/devops/argo-workflow/argo-workflow-2/</guid>
      <description>Argo Workflow (2) 1 Steps 多步骤的工作流可以通过steps字段来定义。每个步骤都是一个独立的容器，可以并行执行。&#xA;apiVersion: argoproj.io/v1alpha1 kind: Workflow metadata: generateName: steps- spec: entrypoint: hello-hello-hello # This spec contains two templates: hello-hello-hello and whalesay templates: - name: hello-hello-hello # Instead of just running a container # This template has a sequence of steps steps: - - name: hello1 # hello1 is run before the following steps template: argosay arguments: parameters: - name: message value: &amp;#34;hello1&amp;#34; - - name: hello2a # double dash =&amp;gt; run after previous step template: argosay arguments: parameters: - name: message value: &amp;#34;hello2a&amp;#34; - name: hello2b # single dash =&amp;gt; run in parallel with previous step template: argosay arguments: parameters: - name: message value: &amp;#34;hello2b&amp;#34; # This is the same template as from the previous example - name: argosay inputs: parameters: - name: message container: image: yky8/argosay:v2 command: [ &amp;#34;/usr/local/bin/argosay&amp;#34; ] args: [ &amp;#34;echo&amp;#34;,&amp;#34;{{inputs.</description>
    </item>
    <item>
      <title>Argo Workflow 1</title>
      <link>https://Greenery-S.github.io/zh-cn/posts/devops/argo-workflow/argo-workflow-1/</link>
      <pubDate>Sat, 25 May 2024 03:46:15 +0800</pubDate>
      <guid>https://Greenery-S.github.io/zh-cn/posts/devops/argo-workflow/argo-workflow-1/</guid>
      <description>Argo Workflow (1) 大量例子在此: https://github.com/argoproj/argo-workflows/tree/main/examples 但是,由于docker/whalesay镜像不再支持,导致很多例子无法运行,需要自己构建一个镜像来替代它.&#xA;1 Argo CLI argo submit hello-world.yaml # submit a workflow spec to Kubernetes argo list # list current workflows argo get hello-world-xxx # get info about a specific workflow argo logs hello-world-xxx # print the logs from a workflow argo delete hello-world-xxx # delete workflow 用kubectl也可以, 都要指定namespace&#xA;2 Hello World apiVersion: argoproj.io/v1alpha1 kind: Workflow # new type of k8s spec metadata: generateName: hello-world- # name of the workflow spec spec: entrypoint: argosay # invoke the whalesay template templates: - name: argosay # name of the template container: image: yky8/argosay:v2 command: [&amp;#34;/usr/local/bin/argosay&amp;#34;] args: [&amp;#34;echo&amp;#34;, &amp;#34;hello world!</description>
    </item>
    <item>
      <title>Quick Start With Self Build Image</title>
      <link>https://Greenery-S.github.io/zh-cn/posts/devops/argo-workflow/quick-start-with-self-build-image/</link>
      <pubDate>Sat, 25 May 2024 02:17:44 +0800</pubDate>
      <guid>https://Greenery-S.github.io/zh-cn/posts/devops/argo-workflow/quick-start-with-self-build-image/</guid>
      <description>比较坎坷的 &amp;ldquo;Quick&amp;rdquo; Start 最近想复习一下argo workflow，于是打算从官方文档开始，按照文档的步骤一步步来。然而，事情并没有那么顺利。官方的 docker/whalesay 镜像在新的docker版本下不支持了,这导致数百个以此为基础的hello world示例都无法正常运行。于是我决定自己构建一个镜像，来替代官方的docker/whalesay镜像。&#xA;1 创建本地k8s集群 用miniKube创建一个本地的k8s集群，方便测试。&#xA;brew install minikube minikube start minikube dashboard 2 下载argo workflow kubectl create namespace argo kubectl apply -n argo -f https://github.com/argoproj/argo-workflows/releases/download/v&amp;lt;&amp;lt;ARGO_WORKFLOWS_VERSION&amp;gt;&amp;gt;/quick-start-minimal.yaml 3 构建自己的镜像 Copy whalesay 的逻辑到 argosay 这个大概用法就是 argosay [command] [args], 然后根据command执行不同的逻辑。&#xA;如果command是空的，就输出&amp;quot;hello argo&amp;quot; 如果command是assert_contains，就在第二个参数中查找第三个参数 如果command是cat，就输出第二个参数的内容 如果command是echo，就输出第二个参数的内容 如果command是exit，就退出 如果command是sleep，就睡眠 如果command是sh，就执行第二个参数的shell命令 其他情况，就退出 # argosay #!/bin/sh set -eu case ${1:-} in &amp;#39;&amp;#39;) echo &amp;#34;hello argo&amp;#34; ;; assert_contains) grep -F &amp;#34;$3&amp;#34; &amp;#34;$2&amp;#34; ;; cat) cat &amp;#34;$2&amp;#34; ;; echo) case $# in 1) echo &amp;#34;hello argo&amp;#34; ;; 2) echo &amp;#34;$2&amp;#34; ;; 3) mkdir -p &amp;#34;$(dirname $3)&amp;#34; echo &amp;#34;$2&amp;#34; &amp;gt; &amp;#34;$3&amp;#34; sleep 0.</description>
    </item>
    <item>
      <title>Hash Function vs Symmetric Encryption</title>
      <link>https://Greenery-S.github.io/zh-cn/posts/go/encryption/hash-function-vs-symmetric-encryption/</link>
      <pubDate>Wed, 22 May 2024 23:29:47 +0800</pubDate>
      <guid>https://Greenery-S.github.io/zh-cn/posts/go/encryption/hash-function-vs-symmetric-encryption/</guid>
      <description>对称加密和散列算法的核心区别 1 对称加密 目的: 保护数据的机密性，使其无法被未授权方读取。&#xA;工作原理: 使用相同的密钥对数据进行加密和解密。&#xA;特点:&#xA;可逆性：可以使用相同的密钥解密密文得到原始数据。 密钥管理：需要安全地共享密钥，否则数据无法解密。 应用场景: 安全通信、数据存储、数字签名等。&#xA;2 散列算法 目的: 验证数据的完整性和真实性。&#xA;工作原理: 将任意长度的输入转换为固定长度的哈希值。&#xA;特点:&#xA;单向性：无法从哈希值推算出原始数据。 抗碰撞性：难以找到两个不同的输入产生相同的哈希值。 完整性：数据的任何修改都会导致哈希值改变。 应用场景: 文件完整性校验、密码存储、数字签名等。&#xA;3 总结 特性 对称加密 散列算法 目的 保密性 完整性和真实性 可逆性 可逆 不可逆 密钥管理 需要密钥管理 无需密钥管理 输出 加密数据 哈希值 对称加密和散列算法都是重要的密码学技术，用于保护数据的安全。它们在工作原理、应用场景和安全性等方面都有所不同。选择哪种技术取决于具体的应用需求。</description>
    </item>
    <item>
      <title>Open Compare to Openfile</title>
      <link>https://Greenery-S.github.io/zh-cn/posts/go/memo/open-compare-to-openfile/</link>
      <pubDate>Wed, 22 May 2024 22:15:28 +0800</pubDate>
      <guid>https://Greenery-S.github.io/zh-cn/posts/go/memo/open-compare-to-openfile/</guid>
      <description>os.Open 与 os.OpenFile 1 差异 在 Go 语言中，os.Open 和 os.OpenFile 都是用于打开文件的函数，但它们的使用场景和功能有所不同。&#xA;os.Open：这是一个较为简单的打开文件的函数，它只接受一个参数，即要打开的文件的路径。它以只读模式打开文件，如果文件不存在，它会返回一个错误。 file, err := os.Open(&amp;#34;example.txt&amp;#34;) if err != nil { log.Fatal(err) } defer file.Close() os.OpenFile：这是一个更为强大的打开文件的函数，它接受三个参数：文件路径、打开文件的模式和文件权限。它可以以各种模式（如只读、只写、读写、追加、创建等）打开文件，如果文件不存在，它可以创建一个新文件。 file, err := os.OpenFile(&amp;#34;example.txt&amp;#34;, os.O_CREATE|os.O_WRONLY, 0644) if err != nil { log.Fatal(err) } defer file.Close() 在这个例子中，os.OpenFile 以写入模式打开文件，如果文件不存在，它会创建一个新文件。文件的权限被设置为 0644，这意味着文件所有者可以读写文件，而其他用户只能读取文件。&#xA;总的来说，如果你只需要以只读模式打开文件，可以使用 os.Open。如果你需要更多的控制（如设置文件权限，或以不同的模式打开文件），则应使用 os.OpenFile。&#xA;2 模式与权限 当你在 Go 语言中使用 os.OpenFile 函数打开或创建文件时，你需要指定两个参数：模式（flag）和权限（permission）。&#xA;模式（flag） 这个参数决定了你如何打开文件。Go 语言提供了一些预定义的常量来设置这个参数：&#xA;os.O_RDONLY：以只读模式打开文件。 os.O_WRONLY：以只写模式打开文件。 os.O_RDWR：以读写模式打开文件。 os.O_APPEND：在写入数据时，将数据追加到文件的末尾，而不是覆盖现有的内容。 os.O_CREATE：如果文件不存在，就创建一个新文件。 os.O_TRUNC：如果文件已经存在，就先清空文件的内容，然后再写入数据。 这些常量可以通过逻辑 OR 运算符（|）组合在一起，以设置多个模式。例如，os.O_CREATE|os.O_WRONLY 会以只写模式打开文件，如果文件不存在，就创建一个新文件。&#xA;权限（permission） 这个参数决定了文件的权限。它是一个八进制数，通常由三个数字组成。每个数字分别代表文件所有者、文件所属的用户组和其他用户的权限。&#xA;第一个数字代表文件所有者的权限。 第二个数字代表文件所属的用户组的权限。 第三个数字代表其他用户的权限。 每个数字都是 0 到 7 的整数，代表以下三种权限的组合：</description>
    </item>
  </channel>
</rss>
