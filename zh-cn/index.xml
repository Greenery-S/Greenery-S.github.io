<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Greenery&#39;s Blog Site</title>
    <link>https://Greenery-S.github.io/zh-cn/</link>
    <description>Recent content on Greenery&#39;s Blog Site</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <copyright>&lt;a href=&#34;https://creativecommons.org/licenses/by-nc/4.0/&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;CC BY-NC 4.0&lt;/a&gt;</copyright>
    <lastBuildDate>Sat, 25 May 2024 03:46:15 +0800</lastBuildDate>
    <atom:link href="https://Greenery-S.github.io/zh-cn/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Argo Workflow 1</title>
      <link>https://Greenery-S.github.io/zh-cn/posts/devops/argo-workflow/argo-workflow-1/</link>
      <pubDate>Sat, 25 May 2024 03:46:15 +0800</pubDate>
      <guid>https://Greenery-S.github.io/zh-cn/posts/devops/argo-workflow/argo-workflow-1/</guid>
      <description>Argo Workflow (1) 大量例子在此: https://github.com/argoproj/argo-workflows/tree/main/examples 但是,由于docker/whalesay镜像不再支持,导致很多例子无法运行,需要自己构建一个镜像来替代它.&#xA;1 Argo CLI argo submit hello-world.yaml # submit a workflow spec to Kubernetes argo list # list current workflows argo get hello-world-xxx # get info about a specific workflow argo logs hello-world-xxx # print the logs from a workflow argo delete hello-world-xxx # delete workflow 用kubectl也可以, 都要指定namespace&#xA;2 Hello World apiVersion: argoproj.io/v1alpha1 kind: Workflow # new type of k8s spec metadata: generateName: hello-world- # name of the workflow spec spec: entrypoint: argosay # invoke the whalesay template templates: - name: argosay # name of the template container: image: yky8/argosay:v2 command: [&amp;#34;/usr/local/bin/argosay&amp;#34;] args: [&amp;#34;echo&amp;#34;, &amp;#34;hello world!</description>
    </item>
    <item>
      <title>Quick Start With Self Build Image</title>
      <link>https://Greenery-S.github.io/zh-cn/posts/devops/argo-workflow/quick-start-with-self-build-image/</link>
      <pubDate>Sat, 25 May 2024 02:17:44 +0800</pubDate>
      <guid>https://Greenery-S.github.io/zh-cn/posts/devops/argo-workflow/quick-start-with-self-build-image/</guid>
      <description>比较坎坷的 &amp;ldquo;Quick&amp;rdquo; Start 最近想复习一下argo workflow，于是打算从官方文档开始，按照文档的步骤一步步来。然而，事情并没有那么顺利。官方的 docker/whalesay 镜像在新的docker版本下不支持了,这导致数百个以此为基础的hello world示例都无法正常运行。于是我决定自己构建一个镜像，来替代官方的docker/whalesay镜像。&#xA;1 创建本地k8s集群 用miniKube创建一个本地的k8s集群，方便测试。&#xA;brew install minikube minikube start 2 下载argo workflow kubectl create namespace argo kubectl apply -n argo -f https://github.com/argoproj/argo-workflows/releases/download/v&amp;lt;&amp;lt;ARGO_WORKFLOWS_VERSION&amp;gt;&amp;gt;/quick-start-minimal.yaml 3 构建自己的镜像 Copy whalesay 的逻辑到 argosay 这个大概用法就是 argosay [command] [args], 然后根据command执行不同的逻辑。&#xA;如果command是空的，就输出&amp;quot;hello argo&amp;quot; 如果command是assert_contains，就在第二个参数中查找第三个参数 如果command是cat，就输出第二个参数的内容 如果command是echo，就输出第二个参数的内容 如果command是exit，就退出 如果command是sleep，就睡眠 如果command是sh，就执行第二个参数的shell命令 其他情况，就退出 # argosay #!/bin/sh set -eu case ${1:-} in &amp;#39;&amp;#39;) echo &amp;#34;hello argo&amp;#34; ;; assert_contains) grep -F &amp;#34;$3&amp;#34; &amp;#34;$2&amp;#34; ;; cat) cat &amp;#34;$2&amp;#34; ;; echo) case $# in 1) echo &amp;#34;hello argo&amp;#34; ;; 2) echo &amp;#34;$2&amp;#34; ;; 3) mkdir -p &amp;#34;$(dirname $3)&amp;#34; echo &amp;#34;$2&amp;#34; &amp;gt; &amp;#34;$3&amp;#34; sleep 0.</description>
    </item>
    <item>
      <title>Hash Function vs Symmetric Encryption</title>
      <link>https://Greenery-S.github.io/zh-cn/posts/go/encryption/hash-function-vs-symmetric-encryption/</link>
      <pubDate>Wed, 22 May 2024 23:29:47 +0800</pubDate>
      <guid>https://Greenery-S.github.io/zh-cn/posts/go/encryption/hash-function-vs-symmetric-encryption/</guid>
      <description>对称加密和散列算法的核心区别 1 对称加密 目的: 保护数据的机密性，使其无法被未授权方读取。&#xA;工作原理: 使用相同的密钥对数据进行加密和解密。&#xA;特点:&#xA;可逆性：可以使用相同的密钥解密密文得到原始数据。 密钥管理：需要安全地共享密钥，否则数据无法解密。 应用场景: 安全通信、数据存储、数字签名等。&#xA;2 散列算法 目的: 验证数据的完整性和真实性。&#xA;工作原理: 将任意长度的输入转换为固定长度的哈希值。&#xA;特点:&#xA;单向性：无法从哈希值推算出原始数据。 抗碰撞性：难以找到两个不同的输入产生相同的哈希值。 完整性：数据的任何修改都会导致哈希值改变。 应用场景: 文件完整性校验、密码存储、数字签名等。&#xA;3 总结 特性 对称加密 散列算法 目的 保密性 完整性和真实性 可逆性 可逆 不可逆 密钥管理 需要密钥管理 无需密钥管理 输出 加密数据 哈希值 对称加密和散列算法都是重要的密码学技术，用于保护数据的安全。它们在工作原理、应用场景和安全性等方面都有所不同。选择哪种技术取决于具体的应用需求。</description>
    </item>
    <item>
      <title>Open Compare to Openfile</title>
      <link>https://Greenery-S.github.io/zh-cn/posts/go/memo/open-compare-to-openfile/</link>
      <pubDate>Wed, 22 May 2024 22:15:28 +0800</pubDate>
      <guid>https://Greenery-S.github.io/zh-cn/posts/go/memo/open-compare-to-openfile/</guid>
      <description>os.Open 与 os.OpenFile 1 差异 在 Go 语言中，os.Open 和 os.OpenFile 都是用于打开文件的函数，但它们的使用场景和功能有所不同。&#xA;os.Open：这是一个较为简单的打开文件的函数，它只接受一个参数，即要打开的文件的路径。它以只读模式打开文件，如果文件不存在，它会返回一个错误。 file, err := os.Open(&amp;#34;example.txt&amp;#34;) if err != nil { log.Fatal(err) } defer file.Close() os.OpenFile：这是一个更为强大的打开文件的函数，它接受三个参数：文件路径、打开文件的模式和文件权限。它可以以各种模式（如只读、只写、读写、追加、创建等）打开文件，如果文件不存在，它可以创建一个新文件。 file, err := os.OpenFile(&amp;#34;example.txt&amp;#34;, os.O_CREATE|os.O_WRONLY, 0644) if err != nil { log.Fatal(err) } defer file.Close() 在这个例子中，os.OpenFile 以写入模式打开文件，如果文件不存在，它会创建一个新文件。文件的权限被设置为 0644，这意味着文件所有者可以读写文件，而其他用户只能读取文件。&#xA;总的来说，如果你只需要以只读模式打开文件，可以使用 os.Open。如果你需要更多的控制（如设置文件权限，或以不同的模式打开文件），则应使用 os.OpenFile。&#xA;2 模式与权限 当你在 Go 语言中使用 os.OpenFile 函数打开或创建文件时，你需要指定两个参数：模式（flag）和权限（permission）。&#xA;模式（flag） 这个参数决定了你如何打开文件。Go 语言提供了一些预定义的常量来设置这个参数：&#xA;os.O_RDONLY：以只读模式打开文件。 os.O_WRONLY：以只写模式打开文件。 os.O_RDWR：以读写模式打开文件。 os.O_APPEND：在写入数据时，将数据追加到文件的末尾，而不是覆盖现有的内容。 os.O_CREATE：如果文件不存在，就创建一个新文件。 os.O_TRUNC：如果文件已经存在，就先清空文件的内容，然后再写入数据。 这些常量可以通过逻辑 OR 运算符（|）组合在一起，以设置多个模式。例如，os.O_CREATE|os.O_WRONLY 会以只写模式打开文件，如果文件不存在，就创建一个新文件。&#xA;权限（permission） 这个参数决定了文件的权限。它是一个八进制数，通常由三个数字组成。每个数字分别代表文件所有者、文件所属的用户组和其他用户的权限。&#xA;第一个数字代表文件所有者的权限。 第二个数字代表文件所属的用户组的权限。 第三个数字代表其他用户的权限。 每个数字都是 0 到 7 的整数，代表以下三种权限的组合：</description>
    </item>
    <item>
      <title>File Encryption</title>
      <link>https://Greenery-S.github.io/zh-cn/posts/go/encryption/file-encryption/</link>
      <pubDate>Wed, 22 May 2024 17:42:47 +0800</pubDate>
      <guid>https://Greenery-S.github.io/zh-cn/posts/go/encryption/file-encryption/</guid>
      <description>文件加密 code: https://github.com/Greenery-S/go-encryption/tree/master/enc_file&#xA;1 对称加密 加密过程的每一步都是可逆的 加密和解密用的是同一组密钥 异或是最简单的对称加密算法 典型对称加密算法：DES（Data Encryption Standard）AES(Advanced Encryption Standard)&#xA;2 分组加密 分组加密：对原始数据（明文）进行分组，每组64位，最后一组不足64位时按一定规则填充。每一组上单独施加DES算法 CBC（Cipher Block Chaining）密文分组链接模式，将当前明文分组与前一个密文分组进行异或运算，然后再进行加密 代码见code链接.&#xA;数字填充 PKCS#5 和 PKCS#7 是两种常见的数据填充标准，它们都属于 PKCS (Public-Key Cryptography Standards) 系列标准的一部分。&#xA;PKCS#5：主要用于描述密码学中的分组密码的填充方式。在实际应用中，当数据块的大小不是密码算法所需要的固定长度时，就需要进行填充。PKCS#5 填充方式是在数据块末尾填充一个字节序列，每个字节的值等于缺少的字节的数量。例如，如果数据块长度为 6，而密码算法需要的长度为 8，则需要在数据块末尾填充两个字节，每个字节的值为 2。 PKCS#7：是 PKCS#5 的扩展，它支持任何长度的数据块，而不仅仅是 8 字节。PKCS#7 的填充方式与 PKCS#5 相同，都是在数据块末尾填充一个字节序列，每个字节的值等于缺少的字节的数量。 // pkcs7padding和pkcs5padding的填充方式相同，填充字节的值都等于填充字节的个数。 // 例如需要填充4个字节，则填充的值为&amp;#34;4 4 4 4&amp;#34;。 var ( // only difference is the block size, PKCS5 is 8 bytes, PKCS7 can be any bytes PKCS5 = &amp;amp;pkcs5{} PKCS7 = &amp;amp;pkcs5{} ErrPaddingSize = errors.</description>
    </item>
    <item>
      <title>Introduction to Clickhouse</title>
      <link>https://Greenery-S.github.io/zh-cn/posts/go/database/introduction-to-clickhouse/</link>
      <pubDate>Wed, 22 May 2024 15:08:40 +0800</pubDate>
      <guid>https://Greenery-S.github.io/zh-cn/posts/go/database/introduction-to-clickhouse/</guid>
      <description>ClickHouse code: https://github.com/Greenery-S/go-database/tree/master/clickhouse&#xA;1 简介 ClickHouse是一个用于联机分析（OLAP）的列式数据库管理系统（DBMS）。&#xA;在传统的行式数据库系统（MySQL、SQL Server）中，处于同一行中的数据总是被物理的存储在一起。在列式数据库系统（ClickHouse、HBase、Druid）中，来自同一列的数据被存储在一起。&#xA;OLAP场景的关键特征 (基于埋点数据进行业务的统计分析):&#xA;绝大多数是读请求，已添加到数据库的数据不能修改 宽表，即每个表包含着大量的列 对于读取，从数据库中提取相当多的行，但只提取列的一小部分 查询相对较少（通常每台服务器每秒查询数百次或更少） 对于简单查询，允许延迟大约50毫秒 列中的数据相对较小：数字和短字符串（例如，每个URL 60个字节） 处理单个查询时需要高吞吐量（每台服务器每秒可达数十亿行） 事务不是必须的 2 使用方法 它的SQL语法和MySQL类似，但是有一些不同之处。&#xA;创建数据库,表：&#xA;create database test; -- json type is experimental feature set allow_experimental_object_type = 1; CREATE TABLE test.user ( user_id UInt32 comment &amp;#39;用户ID&amp;#39;, -- 用户ID name String comment &amp;#39;用户姓名&amp;#39;, -- 用户名 create_time DateTime comment &amp;#39;注册时间&amp;#39;, -- 注册时间 extra Json comment &amp;#39;附加信息&amp;#39; -- 附加信息,json可自由扩充字段 ) ENGINE = MergeTree() PRIMARY KEY (create_time); 查询数据:</description>
    </item>
    <item>
      <title>Introduction to Mongo</title>
      <link>https://Greenery-S.github.io/zh-cn/posts/go/database/introduction-to-mongo/</link>
      <pubDate>Wed, 22 May 2024 01:23:35 +0800</pubDate>
      <guid>https://Greenery-S.github.io/zh-cn/posts/go/database/introduction-to-mongo/</guid>
      <description>MongoDB code: https://github.com/Greenery-S/go-database/tree/master/mongo&#xA;1 简介 Mongo是一个面向文档存储的数据库，它跟关系型数据库的概念对比如下。 Mongo最大的特点是模式自由，即你可以将结构完全不同的文档存储同一个集合中。特别适合于业务初期，表字段不稳定的时候。 相比于MySQL，Mongo更适合存储大尺寸、低价值的数据，大文档的读写性能比MySQL好。 2 语法 use test; 切换到test库，如果没有则（创建集合时）会自动创建 show collections 查看库里有哪些集合 db.createCollection(&amp;#34;student&amp;#34;); 创建collection db.createUser({user: &amp;#34;tester&amp;#34;,pwd: &amp;#34;123456&amp;#34;, roles: [{role: &amp;#34;dbAdmin&amp;#34;, db: &amp;#34;test&amp;#34;}]});创建用户 用刚创建的tester用户身份登录： mongo --port 27017 -u &amp;#34;tester&amp;#34; -p &amp;#34;123456&amp;#34; --authenticationDatabase &amp;#34;test&amp;#34; db.student.createIndex({name:1,unique:1})在name上创建唯一索引,1表示升序，-1表示降序 db.student.dropIndex(&amp;#34; name_1_unique_1 &amp;#34;) 删除索引 db.student.getIndexes() 查看索引 db.student.insertOne({name:&amp;#34;张三&amp;#34;,city:&amp;#34;北京&amp;#34;}); 插入一条记录 db.student.insertMany([{name:&amp;#34;张三&amp;#34;,city:&amp;#34;北京&amp;#34;},{name:&amp;#34;李四&amp;#34;,gender:&amp;#34;女&amp;#34;}]) 插入多条记录 db.student.find({name:&amp;#34;张三&amp;#34;}); 查找满足条件的记录 db.student.find({}); 查看集合里的全部内容 db.student.updateOne({name:&amp;#34;张三&amp;#34;},{$set:{gender:&amp;#34;女&amp;#34;}}) 更新一条记录 db.student.updateMany({name:&amp;#34;张三&amp;#34;},{$set:{gender:&amp;#34;女&amp;#34;}}) 更新满足条件的所有记录 db.student.deleteOne({name:&amp;#34;张三&amp;#34;}); db.student.deleteMany({name:&amp;#34;张三&amp;#34;}); 删除记录 db.student.drop() 删除集合 3 Go操作Mongo 连接 func main() { ctx := context.Background() option := options.</description>
    </item>
    <item>
      <title>Be Careful When Choosing House</title>
      <link>https://Greenery-S.github.io/zh-cn/posts/life/singapore/be-careful-when-choosing-house/</link>
      <pubDate>Wed, 22 May 2024 00:43:27 +0800</pubDate>
      <guid>https://Greenery-S.github.io/zh-cn/posts/life/singapore/be-careful-when-choosing-house/</guid>
      <description>来新加坡，选择住处时要慎重 来新加坡，选择住处时要慎重。&#xA;什么是穷人的房子？我指的是那些把自住的房子出租其中一间的人。&#xA;这些房东通常经济压力较大。一方面，他们买了HDB，却需要通过出租房间来减轻贷款压力；另一方面，他们虽然敞开家门，但可能对租户非常挑剔，容易产生矛盾，最终生活得像学生宿舍一样不和谐。&#xA;让我先说说正常的租房流程：看房、交押金、入住、交月租、退房、验房、退押金。只要保证退房时的房间和入住时一样，几乎不应该扣押金。就像计算机中的“最终一致性”：你只要保证最后交房时的状态是OK的，那就没问题。我住过的网红公寓Interlace Place就是这样，房东或中介不会干涉你的正常生活。&#xA;然而，住“穷人的房子”会有所不同。房东可能会频繁查看你的房间，怀疑你是否做了什么破坏，有时甚至会侵犯你的隐私。&#xA;更令人困扰的是，有时候房东可能会因为各种原因提前向你催租。例如，我住过的一家房东，每个月都会提前15天甚至23天问我要房租，理由诸如“交学费”、“看病”、“举办宴会”等等，每个月都会出现这样的请求，希望你能理解并帮忙。&#xA;作为程序员，我注重协议和合约，所以对这些情感上的请求并不动摇，而是尽量拒绝提前支付租金，尽量平衡支持房东和保护自己的利益。&#xA;前2个月，我对房东一家非常宽容，他们多次要求提前支付部分租金，我基本都答应了。而且，我几乎每个星期有60%的时间不在房间，出去找朋友玩或者照顾我的妹妹。最终，为了期末复习，我整个月没回来。这个月回来后，我发现他们把提前交租当成了常规操作，完全不尊重我。我当即拒绝了当月的请求，并通过中介表明我的立场，希望他们能够有所收敛。&#xA;昨天，离按合同交房租还有10天，房东再次向我要100刀，但语气已经变得非常恳求。我觉得差不多了，就给了他们这一笔钱，他们非常感激。&#xA;但我感到疲惫。我不喜欢操纵人心，而且这个房子确实不适合长期租住。我联系了酒店包月的项目，决定整月租酒店。我和房东谈了这件事，知道押金可能无法全额退还，于是主动提出只要50%的押金。然而，他们真的是经济困难，求我多租一个月，把押金当做那个月的租金。我知道自己可能会有些损失，但也只能接受。&#xA;新加坡的很多人生活不易，尤其是经济困难的家庭。我们无法改变所有人的境遇，只能选择合适的住处，避免不必要的麻烦。希望每个人都能找到适合自己的生活方式。</description>
    </item>
    <item>
      <title>Introduction to Redis</title>
      <link>https://Greenery-S.github.io/zh-cn/posts/go/database/introduction-to-redis/</link>
      <pubDate>Sun, 19 May 2024 22:11:16 +0800</pubDate>
      <guid>https://Greenery-S.github.io/zh-cn/posts/go/database/introduction-to-redis/</guid>
      <description>Redis code: https://github.com/Greenery-S/go-database/tree/master/redis&#xA;1 简介 Redis是一个基于内存的数据存储系统。 基于内存，所以快，是Mysql的10到100倍。 为防止数据丢失，数据会周期性地持久化到磁盘。 Redis跟业务程序是分开部署的，所以Redis可以充当分布式缓存。 支持丰富的数据类型：字符串（String）、哈希（Hash）、列表（List）、集合（Set）和有序集合（Sorted Set）。 支持发布/订阅模式，发布者将消息发送到指定的频道，订阅者可以接收和处理这些消息。这种模式常应用于实时通信、事件驱动系统和消息队列等场景。 Redis事务太鸡肋，不建议使用。 2 发布/订阅模式 Subscriber启动之前，Channel里的消息接收不到。 广播效果. 3 分布式锁 SetNX(ctx context.Context, key string, value interface{}, expiration time.Duration) *BoolCmd SetNX如果key不存在则返回true，写入key，并设置过期时间 秒杀iphone代码示例：&#xA;func TryLock(rc *redis.Client, key string, expire time.Duration) bool { cmd := rc.SetNX(context.Background(), key, &amp;#34;anything is ok&amp;#34;, expire) if err := cmd.Err(); err == nil { return cmd.Val() } else { return false } } func ReleaseLock(rc *redis.Client, key string) { rc.</description>
    </item>
    <item>
      <title>Orm Realized by Reflect</title>
      <link>https://Greenery-S.github.io/zh-cn/posts/go/database/orm-realized-by-reflect/</link>
      <pubDate>Sun, 19 May 2024 21:50:59 +0800</pubDate>
      <guid>https://Greenery-S.github.io/zh-cn/posts/go/database/orm-realized-by-reflect/</guid>
      <description>ORM核心技术—反射 教程,反射大全: https://zhuanlan.zhihu.com/p/411313885&#xA;code: https://github.com/Greenery-S/go-database/tree/master/orm&#xA;1 反射 什么是反射&#xA;在运行期间（不是编译期间）探知对象的类型信息和内存结构、更新变量、调用它们的方法 何时使用反射&#xA;函数的参数类型是interface{}，需要在运行时对原始类型进行判断，针对不同的类型采取不同的处理方式。比如json.Marshal(v interface{})&#xA;在运行时根据某些条件动态决定调用哪个函数，比如根据配置文件执行相应的算子函数&#xA;建议在初始化环节使用, 频繁调用的api不建议使用&#xA;2 使用例子 3 反射的弊端 代码难以阅读，难以维护 编译期间不能发现类型错误，覆盖测试难度很大，有些bug需要到线上运行很长时间才能发现，可能会造成严重用后果 反射性能很差，通常比正常代码慢一到两个数量级。在对性能要求很高，或大量反复调用的代码块里建议不要使用反射 4 反射的基础数据类型 reflact.Type – 通过reflect.Type获取类型相关的信息&#xA;type Type interface { MethodByName(string) (Method, bool) //根据名称获取方法 Name() string //获取结构体名称 PkgPath() string //包路径 Size() uintptr //占用内存的大小 Kind() Kind //数据类型 Implements(u Type) bool //判断是否实现了某接口 Field(i int) StructField //第i个成员 FieldByIndex(index []int) StructField //根据index路径获取嵌套成员 FieldByName(name string) (StructField, bool) //根据名称获取成员 Len() int //容器的长度 NumIn() int //输出参数的个数 NumOut() int //返回参数的个数 } reflect.</description>
    </item>
  </channel>
</rss>
